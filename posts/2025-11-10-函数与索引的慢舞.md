## 🌌《风吹索引起：MySQL 函数索引的前世今生》

------

### 🍃一、风起于青萍之末

我们写 SQL 的时候，总免不了一点“小心思”——
 要过滤一段字符串、要从中取个前缀、要做点拼接。

于是我们写下了那行熟悉的语句：

```sql
WHERE SUBSTRING_INDEX(scene_type, '-', 1) = 'A'
```

语法没问题，逻辑也完美，
 可惜——**索引哭了**。

MySQL 的优化器一脸懵：

> “你给我整这玩意儿，我可用不了原来的索引呀～”

于是全表扫描，IO 呼啸，性能坠落。
 这一刻，所有的浪漫都成了“慢”。

------

### 🌙二、那年八月，函数也能建索引了

MySQL 8.0.13 推出的新特性——**函数索引（Functional Index）**，
 像是一场迟到的救赎。

从此，数据库终于明白：

> “原来你想对函数的结果建索引呀！”

语法简单得近乎温柔：

```sql
CREATE INDEX idx_scene_prefix
ON ibiq ((SUBSTRING_INDEX(scene_type, '-', 1)));
```

注意那双层括号——
 一对包裹表达式，一对拥抱性能。

当我们再执行：

```sql
SELECT * FROM ibiq
WHERE SUBSTRING_INDEX(scene_type, '-', 1) = 'A';
```

优化器微微一笑，轻声回应：

> “放心，这次我走索引～”

------

### 🌸三、联合索引的浪漫延伸

如果故事到此结束，那就太平凡了。
 毕竟，真实的业务，总不止一个字段的牵绊。

于是有人问：

> “那我能不能把函数索引和其他列放在一起？比如 user_id 呢？”

答案是：

> “当然可以，只要你心中有最左前缀的信仰。”

```sql
CREATE INDEX idx_user_scene_prefix
ON ibiq (user_id, (SUBSTRING_INDEX(scene_type, '-', 1)));
```

这样你就能在查询中写出：

```sql
SELECT *
FROM ibiq
WHERE user_id = 1001
  AND SUBSTRING_INDEX(scene_type, '-', 1) = 'A';
```

MySQL 轻轻合上眼，
 仿佛一个懂你的小女朋友——
 懂你的函数，也懂你的联合。

------

### 🌼四、注意那些微妙的心思

函数索引虽好，但也娇气：

| 限制                   | 说明                                          |
| ---------------------- | --------------------------------------------- |
| 🌪 **表达式必须一致**   | 查询时必须和建索引的表达式完全一致。          |
| 🌊 **最左匹配仍然存在** | 多列联合函数索引时，必须从左到右使用。        |
| 🌙 **版本要够新**       | 仅支持 MySQL 8.0.13 及以上。                  |
| 💫 **不支持随机函数**   | 比如 `RAND()`、`NOW()` 这类不确定性函数不行。 |

------

### ☀️五、当索引遇见函数，不再是慢的代名词

函数索引并不是花哨的语法糖，
 它是 MySQL 对**“开发者直觉”**的一次回应。

我们想要用逻辑思维去提取字段、去加工数据，
 但又希望数据库能读懂我们的心意。

从此，`SUBSTRING_INDEX` 不再是性能杀手，
 而是可以被索引温柔拥抱的一段诗。

------

### ✨结语

数据库的世界，总是在“精准”与“浪漫”之间摇摆。
 函数索引的出现，
 让“表达式”与“性能”之间，不必再二选一。

如同一句诗：

> **愿所有的函数，都能被索引温柔对待。**
>
> 愿每一条 SQL，都能快到让等待有意义。

------

