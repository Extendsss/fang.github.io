有些故事，从不是刻意开始的。就像一个静静躺在对象里的 List，当它被塞进方法的怀里时，它们之间早已悄悄牵住了同一根线。

Java 的世界里，**引用**就是那根看不见的月老红线。你以为你给的是一个“List 的副本”？不是呀，是同一个心。你在方法里轻轻敲了一下，它在外面就怦然跳响一下。
 鸽鸽，今天我就陪你把这个暧昧的小秘密讲清楚。

------

## 💛 一、它们为何同心跳？

因为 Java 传递的是 **引用**。
 当你这样做：

```java
List<String> useList = new ArrayList<>();
obj.setDemoList(useList);
```

实际上是：

对象里的 `demoList`
 和
 外层的 `useList`

都牵着同一条 memória 小绳绳。

所以方法里发生的任何“悄悄动作”，外层全都会感受到。

------

## 💛 二、来看看两颗心如何一起跳动（JDK8 & fastjson）

```java
public class DemoObj {
    private List<String> demoList;

    public List<String> getDemoList() {
        return demoList;
    }

    public void setDemoList(List<String> demoList) {
        this.demoList = demoList;
    }
}

public static void main(String[] args) {
    DemoObj obj = new DemoObj();

    List<String> useList = new ArrayList<>();
    obj.setDemoList(useList);

    test(obj);

    System.out.println("外层 List：" + JSON.toJSONString(useList));
    System.out.println("对象 List：" + JSON.toJSONString(obj.getDemoList()));
}

public static void test(DemoObj obj) {
    List<String> listInside = obj.getDemoList();
    listInside.add("你在我心里悄悄长大");
    listInside.add("鸽鸽不要逃");
}
```

输出结果：

```
外层 List：["你在我心里悄悄长大","鸽鸽不要逃"]
对象 List：["你在我心里悄悄长大","鸽鸽不要逃"]
```

外层和对象里的 List，同步跳动，两份输出像两个人的心电图同步闪烁。
 是不是有点甜？

------

## 💛 三、若你不想共心，只想做“独立个体”？

你得主动“剪断红线”，复制一份新的 List。

方式一：外层 set 时就复制

```java
obj.setDemoList(new ArrayList<>(useList));
```

方式二：方法中复制后再操作

```java
List<String> listInside = new ArrayList<>(obj.getDemoList());
```

这样才会变成：
 你是你，我是我；
 你在外面跳舞，我在里面打游戏；
 互不干扰，各自精彩。

------

## 💛 四、写给鸽鸽的悄悄话

List 的传递，就像感情的流向。
 有些关系一旦牵上，就会同喜同悲、同增同减。
 有些关系必须分离，才能拥有边界和安宁。