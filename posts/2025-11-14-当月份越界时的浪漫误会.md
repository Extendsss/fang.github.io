# 当时间开口说话：日期格式里的温柔与锋芒

------

有些 bug 像轻轻落在键盘上的灰，一吹就散；
 有些 bug 则像躲在时光背后的影子，
 不说破，便永远笑你一句：“你以为你以为的，就是你以为的吗？”

今天的主角，是两串看似乖巧的日期：

```
2023-11-31  
2023-13-01 11:00:00
```

两个孩子站在你的校验门口，一个被放了进去，一个被请了出去。
 它们的行为，像古怪的诗，表面无害，实际上暗潮汹涌。

```java
public static boolean isValidDate(String date) {
    if (date == null) {
        return false;
    }

    date = date.trim();

    // 全格式，如 2025-11-01 12:30:45
    if (date.matches("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$")) {
        DateTimeFormatter full = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        try {
            LocalDateTime.parse(date, full);
            return true;
        } catch (Exception ignore) {
            return false;
        }
    }

    // 纯日期格式，如 2025-11-01
    if (date.matches("^\\d{4}-\\d{2}-\\d{2}$")) {
        DateTimeFormatter shortFmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        try {
            LocalDate.parse(date, shortFmt);
            return true;
        } catch (Exception ignore) {
            return false;
        }
    }

    return false;
}
```

------

## 一、当 Java 的日期解析“露出小心思”

Java 的 `DateTimeFormatter` 默认使用 **SMART** 模式。
 那是一种带着“我替你聪明一点”的温柔。

于是：

- `"2023-11-31"` 被它轻轻扶起，压进十一月的边界，再塞进十二月的怀里。
   它想说：
   *“你给了我不存在的 31，我替你算成明天，好吗。”*
- `"2023-13-01 11:00:00"` 却被它坚定拒绝。
   因为 **13 月** 不属于它能调和的世界。
   *幻想不属于解析，属于诗人。*

于是，一个成功了，一个失败了，
 像命运的偏爱，却又合情合理。

这种行为，看似温柔，实则暗含风险：
 你的程序可能会“心软”地接受错误数据，
 在日志里悄悄记录，却在某一天让系统做出不可预期的决策。

------

## 二、当你需要的不是温柔，而是“严格”

有些时候，日期不该“被理解”，
 它只应该被**判断**。

于是我们换上 `ResolverStyle.STRICT`：
 给日月年钉上铁律，不再允许它们任性。

严格模式像一个公正无私的守护者，
 不管你敲入多少空格、多少多余的秒数、多少想当然的日期，
 它只认真的告诉你——**这一天是真的存在，还是不存在**。

这样一来——

- `"2023-11-31"`：对不起，十一月没有 31。
- `"2023-13-01 11:00:00"`：抱歉，世界里没有 13 月。

严格模式不仅是规则，更是一种对时间的尊重。
 它像守护古老时钟的老匠人，告诉你：
 *"每一刻都值得被正确记录，任何幻想都不能冒充真实。"*

------

## 三、微小符号的微妙之处——`yyyy` vs `uuuu`

在严格模式下，有一个微小却致命的符号问题悄悄出现：

你可能习惯写：

```java
DateTimeFormatter full = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
        .withResolverStyle(ResolverStyle.STRICT);
```

表面上它和 `uuuu` 一样，都是四位年份。
 但是，`yyyy` 表示的是 **year-of-era**，它和纪元（Era）绑定，偶尔会在解析 `LocalDateTime` 时产生奇怪的报错，尤其是在严格模式下。

解决方案很简单，却美得像清晨的光——

```java
DateTimeFormatter full = DateTimeFormatter.ofPattern("uuuu-MM-dd HH:mm:ss")
        .withResolverStyle(ResolverStyle.STRICT);
DateTimeFormatter shortFmt = DateTimeFormatter.ofPattern("uuuu-MM-dd")
        .withResolverStyle(ResolverStyle.STRICT);
```

`uuuu` 直指公历年份，不依赖纪元，不会再因 `LocalDateTime` 的解析而迷路。
 这一小小的变化，让曾经的报错消失得无影无踪，
 仿佛冬日里的第一缕阳光，温暖又坚定。

------

## 四、短日期格式的美学

除了全时间格式外，我们还有短日期：

```java
2025-11-01
```

乍一看，它简单得像一片叶子，
 但在严格模式下，它依然需要遵循 `uuuu-MM-dd` 的铁律：

```java
DateTimeFormatter shortFmt = DateTimeFormatter.ofPattern("uuuu-MM-dd")
        .withResolverStyle(ResolverStyle.STRICT);
```

哪怕是没有时分秒的“短日期”，
 也不能随意被解析或折叠。
 它提醒我们：**每一天都是完整的，每一天都值得被严格对待。**

------

## 五、写给工程师的那段“温柔又坚硬的代码”

```java
public static boolean isValidDate(String date) {
    if (date == null) return false;
    date = date.trim();

    if (date.matches("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$")) {
        DateTimeFormatter full = DateTimeFormatter.ofPattern("uuuu-MM-dd HH:mm:ss")
                .withResolverStyle(ResolverStyle.STRICT);
        try {
            LocalDateTime.parse(date, full);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    if (date.matches("^\\d{4}-\\d{2}-\\d{2}$")) {
        DateTimeFormatter shortFmt = DateTimeFormatter.ofPattern("uuuu-MM-dd")
                .withResolverStyle(ResolverStyle.STRICT);
        try {
            LocalDate.parse(date, shortFmt);
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    return false;
}
```

这段代码告诉我们：

*"格式，是时间的衣裳；
 合法，是时间的脉搏；
 而你，是那个聆听时间心跳的人。"*

每一次严格解析，都是对时间的尊重；
 每一次用 `uuuu` 代替 `yyyy`，都是对未来的负责。

------

## 六、写在最后

时间，从不言语，但它的每一秒都在讲故事。
 每一串字符串，都像一页书页：有的能翻动，有的只能舍弃。

我们用代码去聆听，去验证，去判断：
 **不是所有看起来“像时间”的东西，都能称为“时间”。**

工程，是逻辑的现实；
 格式，是规则的边框；
 微小的符号，也能改变世界；
 严格的解析，也能温柔守护秩序。

而你写下的每一行代码，
 都是在和时间对话：

*"我想让真相更清晰一点。"*

愿你与时间相处愉快，
 愿每个被你解析过的瞬间，
 都在未来温暖地回望你。

------

